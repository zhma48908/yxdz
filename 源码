import asyncio
import subprocess
import json
import re
import os
from datetime import datetime
from typing import Optional, Dict, List, IO
import pandas as pd
from statistics import mean

def generate_vless_config(ip: str, port: int, domain: str, uuid: str = "your-uuid-here", ws_path: str = "/vless") -> Dict:
    """生成临时的 VLESS 配置，使用 ws+tls 协议"""
    # 注意：'vless' 和 'geosite' 是 Xray 的专有关键字，非拼写错误
    config = {
        "log": {"loglevel": "debug"},  # 启用调试日志
        "inbounds": [{
            "port": 10808,  # 本地 SOCKS 端口
            "protocol": "socks",
            "settings": {"udp": True}
        }],
        "outbounds": [{
            "protocol": "vless",
            "settings": {
                "vnext": [{
                    "address": ip,
                    "port": port,
                    "users": [{
                        "id": uuid,  # 动态 UUID
                        "encryption": "none"
                    }]
                }]
            },
            "streamSettings": {
                "network": "ws",
                "security": "tls",
                "wsSettings": {
                    "path": ws_path,  # 动态 WebSocket 路径
                    "headers": {
                        "Host": domain
                    }
                },
                "tlsSettings": {
                    "serverName": domain,
                    "allowInsecure": True  # 允许不验证证书
                }
            }
        }],
        "routing": {
            "rules": [{
                "type": "field",
                "outboundTag": "direct",
                "domain": ["geosite:cn"]
            }]
        }
    }
    return config

async def measure_latency(ip: str, port: int, domain: str, timeout: int = 15, max_retries: int = 5) -> float:
    """通过 VLESS 测量延迟"""
    config = generate_vless_config(ip, port, domain)
    config_file = "temp_config.json"
    process: Optional[asyncio.subprocess.Process] = None

    for attempt in range(max_retries):
        try:
            with open(config_file, "w", encoding="utf-8") as f:  # type: IO[str]
                json.dump(config, f, indent=4)

            # 启动 Xray 进程，捕获日志
            process = await asyncio.create_subprocess_exec(
                "xray", "-c", config_file,
                stdout=subprocess.PIPE, stderr=subprocess.PIPE
            )

            # 等待 Xray 启动
            await asyncio.sleep(1)

            # 使用 curl 通过本地 SOCKS 代理测试延迟
            # 注意：'steamstatic' 是域名的一部分，非拼写错误
            url = f"https://{domain}/steam/apps/256870924/movie_max.mp4"
            start_time = datetime.now()
            result = subprocess.run([
                "curl", "-x", "socks5://127.0.0.1:10808", "-I", "--max-time", str(timeout),
                "--connect-timeout", "7",  # 增加连接超时
                "-H", "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/91.0.4472.124",
                "-H", "Accept: */*",
                "-H", "Referer: https://steamcommunity.com/",
                "--insecure",
                url
            ], capture_output=True, text=True, check=False)
            end_time = datetime.now()

            latency = (end_time - start_time).microseconds / 1000  # 转换为 ms
            if result.returncode != 0:
                print(f"延迟测试尝试 {attempt + 1}/{max_retries} 失败 {ip}:{port}: {result.stderr or result.stdout or '无错误输出'}")
                continue

            return latency

        except asyncio.CancelledError:
            print(f"延迟测试被取消 {ip}:{port}")
            return -1.0
        except Exception as e:
            print(f"延迟测试尝试 {attempt + 1}/{max_retries} 失败 {ip}:{port}: {e}")
            continue
        finally:
            if os.path.exists(config_file):
                os.remove(config_file)
            if process is not None and process.returncode is None:
                process.terminate()
                stdout, stderr = await process.communicate()
                if stderr:
                    print(f"Xray 延迟测试错误输出 {ip}:{port}: {stderr.decode()}")

    print(f"延迟测试所有尝试失败 {ip}:{port}")
    return -1.0

async def measure_speed(ip: str, port: int, domain: str, timeout: int = 30, max_retries: int = 3) -> float:
    """通过 VLESS 测量下载速度"""
    config = generate_vless_config(ip, port, domain)
    config_file = "temp_config.json"
    process: Optional[asyncio.subprocess.Process] = None

    for attempt in range(max_retries):
        try:
            with open(config_file, "w", encoding="utf-8") as f:  # type: IO[str]
                json.dump(config, f, indent=4)

            # 启动 Xray 进程，捕获日志
            process = await asyncio.create_subprocess_exec(
                "xray", "-c", config_file,
                stdout=subprocess.PIPE, stderr=subprocess.PIPE
            )

            # 等待 Xray 启动
            await asyncio.sleep(1)

            # 使用 curl 通过本地 SOCKS 代理下载部分数据，限制大小
            url = f"https://{domain}/steam/apps/256870924/movie_max.mp4"
            temp_file = "temp_download.bin"
            start_time = datetime.now()
            result = subprocess.run([
                "curl", "-x", "socks5://127.0.0.1:10808", "-s", "--max-time", str(timeout),
                "--connect-timeout", "10",
                "-H", "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/91.0.4472.124",
                "-H", "Accept: */*",
                "-H", "Referer: https://steamcommunity.com/",
                "--range", "0-1048576",  # 限制下载 1MB
                "--insecure",
                "-o", temp_file, url
            ], capture_output=True, text=True, check=False)
            end_time = datetime.now()

            time_taken = (end_time - start_time).total_seconds()
            if result.returncode != 0:
                print(f"速度测试尝试 {attempt + 1}/{max_retries} 失败 {ip}:{port}: {result.stderr or result.stdout or '无错误输出'}")
                continue

            # 检查实际下载的文件大小
            downloaded_size = os.path.getsize(temp_file) / 1024 / 1024 if os.path.exists(temp_file) else 0  # 转换为 MB
            if os.path.exists(temp_file):
                os.remove(temp_file)

            if downloaded_size > 0 and time_taken > 0:
                speed_mbps = (downloaded_size / time_taken) * 8  # 转换为 Mbps
                print(f"速度测试成功 {ip}:{port}: 下载 {downloaded_size:.2f} MB, 时间 {time_taken:.2f} s, 速度 {speed_mbps:.2f} Mbps")
                return speed_mbps
            print(f"速度测试失败 {ip}:{port}: 未下载数据或时间过短")
            return 0.0

        except asyncio.CancelledError:
            print(f"速度测试被取消 {ip}:{port}")
            return 0.0
        except Exception as e:
            print(f"速度测试尝试 {attempt + 1}/{max_retries} 失败 {ip}:{port}: {e}")
            continue
        finally:
            if os.path.exists(config_file):
                os.remove(config_file)
            if process is not None and process.returncode is None:
                process.terminate()
                stdout, stderr = await process.communicate()
                if stderr:
                    print(f"Xray 速度测试错误输出 {ip}:{port}: {stderr.decode()}")

    print(f"速度测试所有尝试失败 {ip}:{port}")
    return 0.0

async def test_ip_port(ip_port: str, domain: str, test_count: int = 3, speed_test_count: int = 1) -> Optional[Dict]:
    """测试单个 IP 和端口的性能"""
    if ":" in ip_port:
        ip, port = ip_port.split(":", 1)
    else:
        parts = ip_port.split()
        if len(parts) != 2:
            print(f"跳过无效行: {ip_port}")
            return None
        ip, port = parts[0], parts[1]

    port = int(port)

    # 验证 IP 格式（这里假设都是 IPv4）
    if not re.match(r"^\d+\.\d+\.\d+\.\d+$", ip):
        print(f"跳过无效 IP 格式: {ip}")
        return None

    latencies = []
    for _ in range(test_count):
        latency = await measure_latency(ip, port, domain)
        if latency >= 0:
            latencies.append(latency)
        await asyncio.sleep(0.1)

    speeds = []
    for _ in range(speed_test_count):
        speed = await measure_speed(ip, port, domain)
        if speed > 0:
            speeds.append(speed)
        await asyncio.sleep(0.1)

    average_latency = mean(latencies) if latencies else -1.0
    average_speed_mbps = mean(speeds) if speeds else 0.0
    average_speed_mbs = average_speed_mbps / 8  # 转换为 MB/s

    return {
        "ip": ip,
        "port": port,
        "average_latency": average_latency,
        "average_speed_mbps": average_speed_mbps,
        "average_speed_mbs": average_speed_mbs
    }

def parse_ip_port_file(filename: str) -> List[str]:
    """解析 ips_ports.txt 文件，支持 ':' 和空格分隔"""
    ip_ports = []
    try:
        with open(filename, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith("#"):  # 跳过空行和注释
                    continue
                if ":" in line:
                    ip, port = line.split(":", 1)
                    ip_ports.append(f"{ip}:{port}")
                else:
                    parts = line.split()
                    if len(parts) == 2:
                        ip_ports.append(f"{parts[0]}:{parts[1]}")
                    else:
                        print(f"警告：跳过格式错误的行: {line}")
        return ip_ports
    except FileNotFoundError:
        print(f"错误：找不到 {filename} 文件，请确保文件存在。")
        return []
    except Exception as e:
        print(f"读取文件失败: {e}")
        return []

async def main():
    # 配置
    domain = "cdn.cloudflare.steamstatic.com"  # 测速域名
    test_count = 3  # 延迟测试次数
    speed_test_count = 1  # 速度测试次数

    # 解析 IP 和端口文件
    ip_ports = parse_ip_port_file("ips_ports.txt")
    if not ip_ports:
        return

    # 并发测试所有 IP 和端口
    tasks = [test_ip_port(ip_port, domain, test_count, speed_test_count) for ip_port in ip_ports]
    try:
        results = await asyncio.gather(*[task for task in tasks if task is not None], return_exceptions=True)
    except asyncio.CancelledError:
        print("测试被取消")
        return

    # 过滤掉 None 和异常结果
    valid_results = [r for r in results if isinstance(r, dict) and r is not None]

    if not valid_results:
        print("没有有效的测试结果。")
        return

    # 按照下载速度（MB/s）从大到小排序
    sorted_results = sorted(valid_results, key=lambda x: x["average_speed_mbs"], reverse=True)

    # 输出所有结果
    print("\n所有测试结果（按下载速度 MB/s 排序）：")
    for result in sorted_results:
        print(f"IP: {result['ip']}:{result['port']}")
        latency_str = f"{result['average_latency']:.2f} ms" if result['average_latency'] >= 0 else "无法测试"
        speed_mbps_str = f"{result['average_speed_mbps']:.2f} Mbps" if result['average_speed_mbps'] > 0 else "无法测试"
        speed_mbs_str = f"{result['average_speed_mbs']:.2f} MB/s" if result['average_speed_mbs'] > 0 else "无法测试"
        print(f"  平均延迟: {latency_str}")
        print(f"  平均速度: {speed_mbps_str}")
        print(f"  平均速度（MB/s）: {speed_mbs_str}\n")

    # 找到延迟最低和速度最快的 IP/端口
    best_latency = min(valid_results, key=lambda x: x["average_latency"] if x["average_latency"] >= 0 else float('inf'))
    best_speed = max(valid_results, key=lambda x: x["average_speed_mbs"] if x["average_speed_mbs"] > 0 else float('-inf'))

    # 输出最优结果
    print("最优结果：")
    if best_latency["average_latency"] >= 0:
        print(f"延迟最低的 IP/端口: {best_latency['ip']}:{best_latency['port']}")
        print(f"  平均延迟: {best_latency['average_latency']:.2f} ms")
        print(f"  平均速度: {best_latency['average_speed_mbps']:.2f} Mbps" if best_latency['average_speed_mbps'] > 0 else "无法测试")
        print(f"  平均速度（MB/s）: {best_latency['average_speed_mbs']:.2f} MB/s" if best_latency['average_speed_mbs'] > 0 else "无法测试")
    else:
        print("未找到延迟可测的 IP/端口。")

    if best_speed["average_speed_mbs"] > 0:
        print(f"速度最快的 IP/端口: {best_speed['ip']}:{best_speed['port']}")
        print(f"  平均延迟: {best_speed['average_latency']:.2f} ms" if best_speed['average_latency'] >= 0 else "无法测试")
        print(f"  平均速度: {best_speed['average_speed_mbps']:.2f} Mbps")
        print(f"  平均速度（MB/s）: {best_speed['average_speed_mbs']:.2f} MB/s")
    else:
        print("未找到速度可测的 IP/端口。")

    # 保存结果到 Excel 文件，添加错误处理
    excel_file = "speed_test_results.xlsx"
    try:
        # 检查文件是否可写
        if os.path.exists(excel_file):
            try:
                with open(excel_file, "a"):
                    pass  # 测试写权限
            except PermissionError:
                # 如果文件被占用，生成带时间戳的文件名
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                excel_file = f"speed_test_results_{timestamp}.xlsx"
                print(f"警告：{excel_file} 被占用，使用新文件名 {excel_file}")

        df = pd.DataFrame([
            {
                "IP": f"{result['ip']}:{result['port']}",
                "平均延迟 (ms)": result['average_latency'] if result['average_latency'] >= 0 else "无法测试",
                "平均速度 (Mbps)": result['average_speed_mbps'] if result['average_speed_mbps'] > 0 else "无法测试",
                "平均速度 (MB/s)": result['average_speed_mbs'] if result['average_speed_mbs'] > 0 else "无法测试"
            }
            for result in sorted_results
        ])
        df.to_excel(excel_file, index=False, engine="openpyxl")
        print(f"\n结果已保存到 {excel_file}")

    except PermissionError as e:
        print(f"错误：无法保存 Excel 文件：{e}")
        print("请确保 speed_test_results.xlsx 未被其他程序占用，或检查目录写权限。")
    except Exception as e:
        print(f"错误：保存 Excel 文件失败：{e}")

    # 保存原始 JSON 结果
    try:
        with open("speed_test_results.json", "w", encoding="utf-8") as f:  # type: IO[str]
            json.dump(valid_results, f, indent=4, ensure_ascii=False)
        print("结果已保存到 speed_test_results.json")
    except Exception as e:
        print(f"错误：保存 JSON 文件失败：{e}")

if __name__ == "__main__":
    asyncio.run(main())
